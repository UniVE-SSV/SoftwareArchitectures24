<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
		<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>build.gradle | Software Architectures</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="build.gradle" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Contents Anatomy of build.gradle Anatomy of build.gradle The build.gradle file contains the configuration that tells gradle how to build the project: inside of it, we have for example the definition of the external dependencies of the project and where to fetch them, and user-defined tasks. This is the build.gradle file from the previous example: plugins { id(&quot;application&quot;) }" />
<meta property="og:description" content="Contents Anatomy of build.gradle Anatomy of build.gradle The build.gradle file contains the configuration that tells gradle how to build the project: inside of it, we have for example the definition of the external dependencies of the project and where to fetch them, and user-defined tasks. This is the build.gradle file from the previous example: plugins { id(&quot;application&quot;) }" />
<link rel="canonical" href="http://localhost:4000/gradle/build.gradle/" />
<meta property="og:url" content="http://localhost:4000/gradle/build.gradle/" />
<meta property="og:site_name" content="Software Architectures" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-09-24T10:25:55+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="build.gradle" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"Article","dateModified":"2024-09-24T10:25:55+00:00","datePublished":"2024-09-24T10:25:55+00:00","description":"Contents Anatomy of build.gradle Anatomy of build.gradle The build.gradle file contains the configuration that tells gradle how to build the project: inside of it, we have for example the definition of the external dependencies of the project and where to fetch them, and user-defined tasks. This is the build.gradle file from the previous example: plugins { id(&quot;application&quot;) }","headline":"build.gradle","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/siteicon.png"}},"url":"http://localhost:4000/gradle/build.gradle/"}</script>
<!-- End Jekyll SEO tag -->

		<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Software Architectures" />

		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700|Roboto:ital,wght@0,100;1,100&display=swap">
		<link rel="stylesheet" href="/css/main.css">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" href="/touch-icon.png" sizes="192x192">
		<link rel="icon" type="image/png" href="/images/favicon.png">

		<!-- -->
	</head>

	<body>
		<header>
			<h1>
				<a href="/"><img src="/images/emblem.svg" width="40" height="40" alt="Software Architectures logo"></a>
				Software Architectures
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav >
				<ul>
					<li class="nav-item top-level ">
						
						<a href="/">Home</a>
					</li>
				</ul>

				<ul>
					
					
						<li class="nav-item top-level current">
							
							<a href="/gradle/introduction/">02. Gradle</a>
							<ul>
								
									<li class="nav-item "><a href="/gradle/introduction/">1. Introduction</a></li>
								
									<li class="nav-item current"><a href="/gradle/build.gradle/">2. build.gradle</a></li>
								
									<li class="nav-item "><a href="/gradle/testing-java-applications/">3. Testing Java Applications</a></li>
								
									<li class="nav-item "><a href="/gradle/example-log4j/">4. Example - log4j</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/docker/introduction/">1. Docker</a>
							<ul>
								
									<li class="nav-item "><a href="/docker/introduction/">1. Introduction</a></li>
								
									<li class="nav-item "><a href="/docker/getting-started/">2. Getting Started</a></li>
								
									<li class="nav-item "><a href="/docker/cli-and-dockerfile/">3. CLI and Dockerfile</a></li>
								
									<li class="nav-item "><a href="/docker/volumes/">4. Volumes</a></li>
								
							</ul>
						</li>
					
				</ul>

				<ul>
					<li class="nav-item top-level ">
						
						<a href="/changelog/"></a>
					</li>
				</ul>
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<h2>02. Gradle</h2>
				<h3>2. build.gradle</h3>
			</div>
			<article class="content">
				<h2>Contents</h2>
<ul id="markdown-toc">
  <li><a href="#anatomy-of-buildgradle" id="markdown-toc-anatomy-of-buildgradle">Anatomy of build.gradle</a>    <ul>
      <li><a href="#plugins" id="markdown-toc-plugins">Plugins</a></li>
      <li><a href="#application" id="markdown-toc-application">Application</a></li>
      <li><a href="#repositories" id="markdown-toc-repositories">Repositories</a></li>
      <li><a href="#dependencies" id="markdown-toc-dependencies">Dependencies</a>        <ul>
          <li><a href="#resolving-dependencies" id="markdown-toc-resolving-dependencies">Resolving dependencies</a></li>
        </ul>
      </li>
      <li><a href="#tasks" id="markdown-toc-tasks">Tasks</a></li>
    </ul>
  </li>
</ul>
<h2 id="anatomy-of-buildgradle">Anatomy of build.gradle</h2>
<p>The build.gradle file contains the configuration that tells gradle how to build the project: inside of it, we have for example the definition of the external dependencies of the project and where to fetch them, and user-defined tasks.
This is the build.gradle file from the previous example:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="nf">plugins</span> <span class="p">{</span>
    <span class="nf">id</span><span class="p">(</span><span class="s">"application"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">group</span> <span class="p">=</span> <span class="s">"org.example"</span>
<span class="n">version</span> <span class="p">=</span> <span class="s">"1.0-SNAPSHOT"</span>

<span class="nf">repositories</span> <span class="p">{</span>
    <span class="nf">mavenCentral</span><span class="p">()</span>
<span class="p">}</span>

<span class="nf">dependencies</span> <span class="p">{</span>
    <span class="nf">testImplementation</span><span class="p">(</span><span class="nf">platform</span><span class="p">(</span><span class="s">"org.junit:junit-bom:5.9.1"</span><span class="p">))</span>
    <span class="nf">testImplementation</span><span class="p">(</span><span class="s">"org.junit.jupiter:junit-jupiter"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">application</span> <span class="p">{</span>
    <span class="n">mainClass</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="s">"org.example.Main"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">tasks</span><span class="p">.</span><span class="nf">test</span> <span class="p">{</span>
    <span class="nf">useJUnitPlatform</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s see the meaning of each block.</p>
<h3 id="plugins">Plugins</h3>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="nf">plugins</span> <span class="p">{</span>
    <span class="nf">id</span><span class="p">(</span><span class="s">"application"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>A <a target="_blank" rel="noopener noreferrer" href="https://docs.gradle.org/current/userguide/plugins.html">Gradle plugin</a> consists of an enhancement of Gradle core that specifies how to build and run the code, targetting specific build type and providing already-defined tasks. Each programming language has its own plugin. If you remember, in the last lesson we changed to the build.gradle, substituting the Java plugin with the application one. We did it because the application plugin is an extension of the Java plugin (in other words, it inherits all the tasks of the Java plugin) that adds, among other things, the “run” task that permits, as we have seen, to run the application. As documentation <a target="_blank" rel="noopener noreferrer" href="https://docs.gradle.org/current/userguide/java_plugin.html#java_plugin">says</a>, <em>“java plugin adds basic building blocks for working with JVM projects. Its feature set has been superseded by other plugins, offering more features based on your project type. Instead of applying it directly to your project, you should look into the java-library or application plugins or one of the supported alternative JVM language.”</em>.<br />
The <a target="_blank" rel="noopener noreferrer" href="https://docs.gradle.org/current/userguide/application_plugin.html">documentation</a> explain well the application plugin.</p>

<p>To summarize, a Plugin is just an extension of the Gradle core that adds tasks and functionality to it.  If we want to be more specific, a Gradle plugin can:</p>
<ol>
  <li>Extend the Gradle model (for example, adding new DSL elements that can be configured)</li>
  <li>Configure the project according to conventions (for example, adding new tasks)</li>
  <li>Apply specific configuration (for example, enforcing organizational standards)
    <h3 id="application">Application</h3>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="nf">application</span> <span class="p">{</span>
    <span class="n">mainClass</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="s">"org.example.Main"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>This block is specific to the application plugin. It tells Gradle that the Main Class of the program (i.e. our entry point) is the class org.example.Main (note that the name should be fully qualified). This is an example of an extension of the Gradle model.</p>
<h3 id="repositories">Repositories</h3>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="nf">repositories</span> <span class="p">{</span>
    <span class="nf">mavenCentral</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>There exist some repositories that host libraries for projects. In the <a target="_blank" rel="noopener noreferrer" href="https://docs.gradle.org/current/userguide/declaring_repositories.html">repositories</a> block, you can specify which repositorie to use. In our example, we use <a target="_blank" rel="noopener noreferrer" href="https://repo.maven.apache.org/maven2/">Maven Central</a>, but we can have more than one repository. Let’s see another example:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="nf">repositories</span> <span class="p">{</span>
    <span class="nf">mavenCentral</span><span class="p">()</span>
    <span class="nf">google</span><span class="p">()</span>
    <span class="nf">maven</span> <span class="p">{</span>
        <span class="n">url</span> <span class="p">=</span> <span class="nf">uri</span><span class="p">(</span><span class="s">"https://repository.jboss.org/maven2"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Here we have multiple repositories. This means that, if we want to fetch a library named “mickeymouse”, if the library does not exist in the first repository declared, gradle will check the existence on the next repository in the list, until it finds something. Let’s see these repositories:</p>
<ol>
  <li>mavencentral() is just a function that returns the maven central library URL.</li>
  <li>google() is the <a target="_blank" rel="noopener noreferrer" href="https://maven.google.com/web/index.html">google maven library</a>.</li>
  <li>the maven block with url variable is a special block that permits the declaration of a custom repository just by adding its URL.</li>
</ol>

<p>Note that these are just examples, and we redirect curious readers to the <a target="_blank" rel="noopener noreferrer" href="https://docs.gradle.org/current/userguide/declaring_repositories.html">official documentation</a>.</p>
<h3 id="dependencies">Dependencies</h3>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="nf">dependencies</span> <span class="p">{</span>
    <span class="nf">testImplementation</span><span class="p">(</span><span class="nf">platform</span><span class="p">(</span><span class="s">"org.junit:junit-bom:5.9.1"</span><span class="p">))</span>
    <span class="nf">testImplementation</span><span class="p">(</span><span class="s">"org.junit.jupiter:junit-jupiter"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>In this block, we define all the <a target="_blank" rel="noopener noreferrer" href="https://docs.gradle.org/current/userguide/declaring_dependencies.html#declaring-dependencies">dependencies</a> (i.e. libraries and/or frameworks) used by the project.<br />
We can have different types of dependencies because we could have different dependencies for different scopes. For example, some dependencies should be used for compiling source code whereas others only need to be available at runtime, or only for executing tests. In our build.gradle we have defined some testImplementation, that is, dependencies only used for testing. Let’s see the meaning of the second line: as you can notice, we have a function, testImplementation. This defines the configuration, i.e. the scope. A scope can be defined in plugins or by the user. For example, for the Java plugin, we have different scopes (we will see here a few of them):</p>
<ol>
  <li>compileOnly: dependencies used only in compile-time.</li>
  <li>runtimeOnly: dependencies used only in run-time.</li>
  <li>testImplementation: dependencies used only for testing.
A comprehensive explanation of Java Plugin dependencies can be found <a target="_blank" rel="noopener noreferrer" href="https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_plugin_and_dependency_management">here</a>. Note that since Application is an extension of the Java plugin, these scopes are available also if you are using the Application plugin. In the next lesson, we will see an example of how we can import (and use) a dependency.<br />
“org.junit.jupiter:junit-jupiter” is the dependency that we want to import. The substring before ‘:’ represents the group (i.e., it is an identifier of an organization, company, or project). After the ‘:’ we have the name of the dependencies (in our case, junit-jupiter).</li>
</ol>

<p>In addition, you could also have another ‘:’ after the name and the last part of the string represents the version of the dependency that you want to use. For example, the first dependency (that has group org.junit, and name junit-bom) is bound to version 5.9.1. If the version is omitted, then Gradle will fetch the latest version of the dependency. This is not always optimal, because if a new version of a runtimeOnly dependency that you are using ships out, the next build of your app could fetch the newer version, and, if the developers introduce some breaking changes, then these changes may break your app.</p>

<p>It is important to say that before using a dependency the developer should check his reliability: is the dependency regularly updated? How many people used it? Does the publisher have a good reputation?</p>
<h4 id="resolving-dependencies">Resolving dependencies</h4>
<p>Gradle has a caching system for dependencies. To resolve a dependency for a project:</p>
<ol>
  <li>First, Look if the artifact is in the cache. Usually, the cache is located in “~.gradle\caches”.</li>
  <li>If this is the case, retrieve and use the artifact.</li>
  <li>If not, connect to the given repositories (the ones specified in the “repositories” block).</li>
  <li>Look to the specific group/name/version.</li>
  <li>Download the desired artifact and cache it.</li>
  <li>Retrieve and use the artifact.
    <h3 id="tasks">Tasks</h3>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="n">tasks</span><span class="p">.</span><span class="nf">test</span> <span class="p">{</span>
    <span class="nf">useJUnitPlatform</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>This block configures test tasks. This task is specific to Java-related plugins. We don’t want to spend too many words on it, but if you are interested, <a target="_blank" rel="noopener noreferrer" href="https://docs.gradle.org/current/userguide/java_testing.html">here</a> more information is present.</p>

<p>Our tasks.test block says that for our project we are going to use JUnit for testing. What is JUnit? We will answer this question in the next lesson.</p>
<div>
Previous: <a href="/SoftwareArchitectures24/gradle/introduction">Gradle - Introduction</a>
</div>
<div>
Next: <a href="/SoftwareArchitectures24/gradle/testing-java-applications">Gradle - Testing Java Applications</a>  
</div>

			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
		</script>
	</body>
</html>
